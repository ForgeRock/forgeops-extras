{
  "metadata" : {
    "realm" : null,
    "entityType" : "ScriptingService",
    "entityId" : "default/globalScripts/157298c0-7d31-4059-a95b-eeb08473b7e5",
    "uid" : "ou=157298c0-7d31-4059-a95b-eeb08473b7e5,ou=globalScripts,ou=default,ou=GlobalConfig,ou=1.0,ou=ScriptingService,ou=services,ou=am-config",
    "sunServiceID" : "globalScript",
    "objectClass" : [ "sunServiceComponent", "top" ],
    "pathParams" : { },
    "ou" : [ "157298c0-7d31-4059-a95b-eeb08473b7e5" ]
  },
  "data" : {
    "_id" : "default/globalScripts/157298c0-7d31-4059-a95b-eeb08473b7e5",
    "_type" : {
      "_id" : "ScriptingService",
      "name" : "ScriptingService",
      "collection" : false
    },
    "createdBy" : "id=dsameuser,ou=user,dc=openam,dc=forgerock,dc=org",
    "evaluatorVersion" : "V1_0",
    "creationDate" : "1433147666269",
    "language" : "JAVASCRIPT",
    "script" : "var fontDetector = (function () {\n    /**\n     * JavaScript code to detect available availability of a\n     * particular font in a browser using JavaScript and CSS.\n     *\n     * Author : Lalit Patel\n     * Website: http://www.lalit.org/lab/javascript-css-font-detect/\n     * License: Apache Software License 2.0\n     *          http://www.apache.org/licenses/LICENSE-2.0\n     * Version: 0.15 (21 Sep 2009)\n     *          Changed comparision font to default from sans-default-default,\n     *          as in FF3.0 font of child element didn't fallback\n     *          to parent element if the font is missing.\n     * Version: 0.2 (04 Mar 2012)\n     *          Comparing font against all the 3 generic font families ie,\n     *          'monospace', 'sans-serif' and 'sans'. If it doesn't match all 3\n     *          then that font is 100% not available in the system\n     * Version: 0.3 (24 Mar 2012)\n     *          Replaced sans with serif in the list of baseFonts\n     */\n    /*\n     * Portions Copyrighted 2013 ForgeRock AS.\n     */\n    var detector = {}, baseFonts, testString, testSize, h, s, defaultWidth = {}, defaultHeight = {}, index;\n\n    // a font will be compared against all the three default fonts.\n    // and if it doesn't match all 3 then that font is not available.\n    baseFonts = ['monospace', 'sans-serif', 'serif'];\n\n    //we use m or w because these two characters take up the maximum width.\n    // And we use a LLi so that the same matching fonts can get separated\n    testString = \"mmmmmmmmmmlli\";\n\n    //we test using 72px font size, we may use any size. I guess larger the better.\n    testSize = '72px';\n\n    h = document.getElementsByTagName(\"body\")[0];\n\n    // create a SPAN in the document to get the width of the text we use to test\n    s = document.createElement(\"span\");\n    s.style.fontSize = testSize;\n    s.innerHTML = testString;\n    for (index in baseFonts) {\n        //get the default width for the three base fonts\n        s.style.fontFamily = baseFonts[index];\n        h.appendChild(s);\n        defaultWidth[baseFonts[index]] = s.offsetWidth; //width for the default font\n        defaultHeight[baseFonts[index]] = s.offsetHeight; //height for the defualt font\n        h.removeChild(s);\n    }\n\n    detector.detect = function(font) {\n        var detected = false, index, matched;\n        for (index in baseFonts) {\n            s.style.fontFamily = font + ',' + baseFonts[index]; // name of the font along with the base font for fallback.\n            h.appendChild(s);\n            matched = (s.offsetWidth !== defaultWidth[baseFonts[index]] || s.offsetHeight !== defaultHeight[baseFonts[index]]);\n            h.removeChild(s);\n            detected = detected || matched;\n        }\n        return detected;\n    };\n\n    return detector;\n}());\n/*\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n *\n * Copyright (c) 2009 Sun Microsystems Inc. All Rights Reserved\n *\n * The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * https://opensso.dev.java.net/public/CDDLv1.0.html or\n * opensso/legal/CDDLv1.0.txt\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at opensso/legal/CDDLv1.0.txt.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n */\n/*\n * Portions Copyrighted 2013 Syntegrity.\n * Portions Copyrighted 2013-2014 ForgeRock AS.\n */\n\nvar collectScreenInfo = function () {\n        var screenInfo = {};\n        if (screen) {\n            if (screen.width) {\n                screenInfo.screenWidth = screen.width;\n            }\n\n            if (screen.height) {\n                screenInfo.screenHeight = screen.height;\n            }\n\n            if (screen.pixelDepth) {\n                screenInfo.screenColourDepth = screen.pixelDepth;\n            }\n        } else {\n            console.warn(\"Cannot collect screen information. screen is not defined.\");\n        }\n        return screenInfo;\n    },\n    collectTimezoneInfo = function () {\n        var timezoneInfo =  {}, offset = new Date().getTimezoneOffset();\n\n        if (offset) {\n            timezoneInfo.timezone = offset;\n        } else {\n            console.warn(\"Cannot collect timezone information. timezone is not defined.\");\n        }\n\n        return timezoneInfo;\n    },\n    collectBrowserPluginsInfo = function () {\n\n        if (navigator && navigator.plugins) {\n            var pluginsInfo = {}, i, plugins = navigator.plugins;\n            pluginsInfo.installedPlugins = \"\";\n\n            for (i = 0; i < plugins.length; i++) {\n                pluginsInfo.installedPlugins = pluginsInfo.installedPlugins + plugins[i].filename + \";\";\n            }\n\n            return pluginsInfo;\n        } else {\n            console.warn(\"Cannot collect browser plugin information. navigator.plugins is not defined.\");\n            return {};\n        }\n\n    },\n// Getting geolocation takes some time and is done asynchronously, hence need a callback which is called once geolocation is retrieved.\n    collectGeolocationInfo = function (callback) {\n        var geolocationInfo = {},\n            successCallback = function(position) {\n                geolocationInfo.longitude = position.coords.longitude;\n                geolocationInfo.latitude = position.coords.latitude;\n                callback(geolocationInfo);\n            }, errorCallback = function(error) {\n                console.warn(\"Cannot collect geolocation information. \" + error.code + \": \" + error.message);\n                callback(geolocationInfo);\n            };\n        if (navigator && navigator.geolocation) {\n            // NB: If user chooses 'Not now' on Firefox neither callback gets called\n            //     https://bugzilla.mozilla.org/show_bug.cgi?id=675533\n            navigator.geolocation.getCurrentPosition(successCallback, errorCallback);\n        } else {\n            console.warn(\"Cannot collect geolocation information. navigator.geolocation is not defined.\");\n            callback(geolocationInfo);\n        }\n    },\n    collectBrowserFontsInfo = function () {\n        var fontsInfo = {}, i, fontsList = [\"cursive\",\"monospace\",\"serif\",\"sans-serif\",\"fantasy\",\"default\",\"Arial\",\"Arial Black\",\n            \"Arial Narrow\",\"Arial Rounded MT Bold\",\"Bookman Old Style\",\"Bradley Hand ITC\",\"Century\",\"Century Gothic\",\n            \"Comic Sans MS\",\"Courier\",\"Courier New\",\"Georgia\",\"Gentium\",\"Impact\",\"King\",\"Lucida Console\",\"Lalit\",\n            \"Modena\",\"Monotype Corsiva\",\"Papyrus\",\"Tahoma\",\"TeX\",\"Times\",\"Times New Roman\",\"Trebuchet MS\",\"Verdana\",\n            \"Verona\"];\n        fontsInfo.installedFonts = \"\";\n\n        for (i = 0; i < fontsList.length; i++) {\n            if (fontDetector.detect(fontsList[i])) {\n                fontsInfo.installedFonts = fontsInfo.installedFonts + fontsList[i] + \";\";\n            }\n        }\n        return fontsInfo;\n    },\n    devicePrint = {};\n\ndevicePrint.screen = collectScreenInfo();\ndevicePrint.timezone = collectTimezoneInfo();\ndevicePrint.plugins = collectBrowserPluginsInfo();\ndevicePrint.fonts = collectBrowserFontsInfo();\n\nif (navigator.userAgent) {\n    devicePrint.userAgent = navigator.userAgent;\n}\nif (navigator.appName) {\n    devicePrint.appName = navigator.appName;\n}\nif (navigator.appCodeName) {\n    devicePrint.appCodeName = navigator.appCodeName;\n}\nif (navigator.appVersion) {\n    devicePrint.appVersion = navigator.appVersion;\n}\nif (navigator.appMinorVersion) {\n    devicePrint.appMinorVersion = navigator.appMinorVersion;\n}\nif (navigator.buildID) {\n    devicePrint.buildID = navigator.buildID;\n}\nif (navigator.platform) {\n    devicePrint.platform = navigator.platform;\n}\nif (navigator.cpuClass) {\n    devicePrint.cpuClass = navigator.cpuClass;\n}\nif (navigator.oscpu) {\n    devicePrint.oscpu = navigator.oscpu;\n}\nif (navigator.product) {\n    devicePrint.product = navigator.product;\n}\nif (navigator.productSub) {\n    devicePrint.productSub = navigator.productSub;\n}\nif (navigator.vendor) {\n    devicePrint.vendor = navigator.vendor;\n}\nif (navigator.vendorSub) {\n    devicePrint.vendorSub = navigator.vendorSub;\n}\nif (navigator.language) {\n    devicePrint.language = navigator.language;\n}\nif (navigator.userLanguage) {\n    devicePrint.userLanguage = navigator.userLanguage;\n}\nif (navigator.browserLanguage) {\n    devicePrint.browserLanguage = navigator.browserLanguage;\n}\nif (navigator.systemLanguage) {\n    devicePrint.systemLanguage = navigator.systemLanguage;\n}\n\n// Attempt to collect geo-location information and return this with the data collected so far.\n// Otherwise, if geo-location fails or takes longer than 30 seconds, auto-submit the data collected so far.\nautoSubmitDelay = 30000;\noutput.value = JSON.stringify(devicePrint);\ncollectGeolocationInfo(function(geolocationInfo) {\n    devicePrint.geolocation = geolocationInfo;\n    output.value = JSON.stringify(devicePrint);\n    submit();\n});",
    "description" : "Default global script for client side Device Id (Match) Authentication Module",
    "lastModifiedBy" : "id=dsameuser,ou=user,dc=openam,dc=forgerock,dc=org",
    "context" : "AUTHENTICATION_CLIENT_SIDE",
    "lastModifiedDate" : "1433147666269",
    "name" : "Device Id (Match) - Client Side"
  }
}