{
  "metadata" : {
    "realm" : null,
    "entityType" : "ScriptingService",
    "entityId" : "default/globalScripts/703dab1a-1921-4981-98dd-b8e5349d8548",
    "uid" : "ou=703dab1a-1921-4981-98dd-b8e5349d8548,ou=globalScripts,ou=default,ou=GlobalConfig,ou=1.0,ou=ScriptingService,ou=services,ou=am-config",
    "sunServiceID" : "globalScript",
    "objectClass" : [ "sunServiceComponent", "top" ],
    "pathParams" : { },
    "ou" : [ "703dab1a-1921-4981-98dd-b8e5349d8548" ]
  },
  "data" : {
    "_id" : "default/globalScripts/703dab1a-1921-4981-98dd-b8e5349d8548",
    "_type" : {
      "_id" : "ScriptingService",
      "name" : "ScriptingService",
      "collection" : false
    },
    "createdBy" : "id=dsameuser,ou=user,dc=openam,dc=forgerock,dc=org",
    "evaluatorVersion" : "V1_0",
    "creationDate" : "1433147666269",
    "language" : "JAVASCRIPT",
    "script" : "/*\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n *\n * Copyright (c) 2009 Sun Microsystems Inc. All Rights Reserved\n *\n * The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * https://opensso.dev.java.net/public/CDDLv1.0.html or\n * opensso/legal/CDDLv1.0.txt\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at opensso/legal/CDDLv1.0.txt.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n */\n/*\n * Portions Copyrighted 2013 Syntegrity.\n * Portions Copyrighted 2013-2018 ForgeRock AS.\n */\n\nvar ScalarComparator = {}, ScreenComparator = {}, MultiValueComparator = {}, UserAgentComparator = {}, GeolocationComparator = {};\n\nvar config = {\n    profileExpiration: 30,              //in days\n    maxProfilesAllowed: 5,\n    maxPenaltyPoints: 0,\n    attributes: {\n        screen: {\n            required: true,\n            comparator: ScreenComparator,\n            args: {\n                penaltyPoints: 50\n            }\n        },\n        plugins: {\n            installedPlugins: {\n                required: false,\n                comparator: MultiValueComparator,\n                args: {\n                    maxPercentageDifference: 10,\n                    maxDifferences: 5,\n                    penaltyPoints: 100\n                }\n            }\n        },\n        fonts: {\n            installedFonts: {\n                required: false,\n                comparator: MultiValueComparator,\n                args: {\n                    maxPercentageDifference: 10,\n                    maxDifferences: 5,\n                    penaltyPoints: 100\n                }\n            }\n        },\n        timezone: {\n            timezone: {\n                required: false,\n                comparator: ScalarComparator,\n                args: {\n                    penaltyPoints: 100\n                }\n            }\n        },\n        userAgent: {\n            required: true,\n            comparator: UserAgentComparator,\n            args: {\n                ignoreVersion: true,\n                penaltyPoints: 100\n            }\n        },\n        geolocation: {\n            required: false,\n            comparator: GeolocationComparator,\n            args: {\n                allowedRange: 100,\t\t\t//in miles\n                penaltyPoints: 100\n            }\n        }\n    }\n};\n\n//---------------------------------------------------------------------------//\n//                           Comparator functions                            //\n//---------------------------------------------------------------------------//\n\nvar all, any, calculateDistance, calculateIntersection, calculatePercentage, nullOrUndefined, splitAndTrim,\n    undefinedLocation;\n\n// ComparisonResult\n\n/**\n * Constructs an instance of a ComparisonResult with the given penalty points.\n *\n * @param penaltyPoints (Number) The penalty points for the comparison (defaults to 0).\n * @param additionalInfoInCurrentValue (boolean) Whether the current value contains more information\n *                                               than the stored value (defaults to false).\n */\nfunction ComparisonResult() {\n\n    var penaltyPoints = 0,\n        additionalInfoInCurrentValue = false;\n\n    if (arguments[0] !== undefined && arguments[1] !== undefined) {\n        penaltyPoints = arguments[0];\n        additionalInfoInCurrentValue = arguments[1];\n    }\n\n    if (arguments[0] !== undefined && arguments[1] === undefined) {\n        if (typeof(arguments[0]) === \"boolean\") {\n            additionalInfoInCurrentValue = arguments[0];\n        } else {\n            penaltyPoints = arguments[0];\n        }\n    }\n\n    this.penaltyPoints = penaltyPoints;\n    this.additionalInfoInCurrentValue = additionalInfoInCurrentValue;\n\n}\n\nComparisonResult.ZERO_PENALTY_POINTS = new ComparisonResult(0);\n\n/**\n * Static method for functional programming.\n *\n * @return boolean true if comparisonResult.isSuccessful().\n */\nComparisonResult.isSuccessful =  function(comparisonResult) {\n    return comparisonResult.isSuccessful();\n};\n\n\n/**\n * Static method for functional programming.\n *\n * @return boolean true if comparisonResult.additionalInfoInCurrentValue.\n */\nComparisonResult.additionalInfoInCurrentValue =  function(comparisonResult) {\n    return comparisonResult.additionalInfoInCurrentValue;\n};\n\n/**\n * Comparison function that can be provided as an argument to array.sort\n */\nComparisonResult.compare = function(first, second) {\n    if (nullOrUndefined(first) && nullOrUndefined(second)) {\n        return 0;\n    } else if (nullOrUndefined(first)) {\n        return -1;\n    } else if (nullOrUndefined(second)) {\n        return 1;\n    } else {\n        if (first.penaltyPoints !== second.penaltyPoints) {\n            return first.penaltyPoints - second.penaltyPoints;\n        } else {\n            return (first.additionalInfoInCurrentValue ? 1 : 0) - (second.additionalInfoInCurrentValue ? 1 : 0);\n        }\n    }\n};\n\n/**\n * Amalgamates the given ComparisonResult into this ComparisonResult.\n *\n * @param comparisonResult The ComparisonResult to include.\n */\nComparisonResult.prototype.addComparisonResult = function(comparisonResult) {\n    this.penaltyPoints += comparisonResult.penaltyPoints;\n    if (comparisonResult.additionalInfoInCurrentValue) {\n        this.additionalInfoInCurrentValue = comparisonResult.additionalInfoInCurrentValue;\n    }\n};\n\n/**\n * Returns true if no penalty points have been assigned for the comparison.\n *\n * @return boolean true if the comparison was successful.\n */\nComparisonResult.prototype.isSuccessful = function() {\n    return nullOrUndefined(this.penaltyPoints) || this.penaltyPoints === 0;\n};\n\n/**\n * Compares two simple objects (String|Number) and if they are equal then returns a ComparisonResult with zero\n * penalty points assigned, otherwise returns a ComparisonResult with the given number of penalty points assigned.\n *\n * @param currentValue (String|Number) The current value.\n * @param storedValue (String|Number) The stored value.\n * @param config: {\n *            \"penaltyPoints\": (Number) The number of penalty points.\n *        }\n * @return ComparisonResult.\n */\nScalarComparator.compare = function (currentValue, storedValue, config) {\n    if (logger.messageEnabled()) {\n        logger.message(\"StringComparator.compare:currentValue: \" + JSON.stringify(currentValue));\n        logger.message(\"StringComparator.compare:storedValue: \" + JSON.stringify(storedValue));\n        logger.message(\"StringComparator.compare:config: \" + JSON.stringify(config));\n    }\n    if (config.penaltyPoints === 0) {\n        return ComparisonResult.ZERO_PENALTY_POINTS;\n    }\n\n    if (!nullOrUndefined(storedValue)) {\n        if (nullOrUndefined(currentValue) || currentValue !== storedValue) {\n            return new ComparisonResult(config.penaltyPoints);\n        }\n    } else if (!nullOrUndefined(currentValue)) {\n        return new ComparisonResult(true);\n    }\n\n    return ComparisonResult.ZERO_PENALTY_POINTS;\n};\n\n/**\n * Compares two screens and if they are equal then returns a ComparisonResult with zero penalty points assigned,\n * otherwise returns a ComparisonResult with the given number of penalty points assigned.\n *\n * @param currentValue: {\n *            \"screenWidth\": (Number) The current client screen width.\n *            \"screenHeight\": (Number) The current client screen height.\n *            \"screenColourDepth\": (Number) The current client screen colour depth.\n *        }\n * @param storedValue: {\n *            \"screenWidth\": (Number) The stored client screen width.\n *            \"screenHeight\": (Number) The stored client screen height.\n *            \"screenColourDepth\": (Number) The stored client screen colour depth.\n *        }\n * @param config: {\n *            \"penaltyPoints\": (Number) The number of penalty points.\n *        }\n * @return ComparisonResult\n */\nScreenComparator.compare = function (currentValue, storedValue, config) {\n    if (logger.messageEnabled()) {\n        logger.message(\"ScreenComparator.compare:currentValue: \" + JSON.stringify(currentValue));\n        logger.message(\"ScreenComparator.compare:storedValue: \" + JSON.stringify(storedValue));\n        logger.message(\"ScreenComparator.compare:config: \" + JSON.stringify(config));\n    }\n\n    if (nullOrUndefined(currentValue)) {\n        currentValue = {screenWidth: null, screenHeight: null, screenColourDepth: null};\n    }\n    if (nullOrUndefined(storedValue)) {\n        storedValue = {screenWidth: null, screenHeight: null, screenColourDepth: null};\n    }\n\n    var comparisonResults = [\n        ScalarComparator.compare(currentValue.screenWidth, storedValue.screenWidth, config),\n        ScalarComparator.compare(currentValue.screenHeight, storedValue.screenHeight, config),\n        ScalarComparator.compare(currentValue.screenColourDepth, storedValue.screenColourDepth, config)];\n\n    if (all(comparisonResults, ComparisonResult.isSuccessful)) {\n        return new ComparisonResult(any(comparisonResults, ComparisonResult.additionalInfoInCurrentValue));\n    } else {\n        return new ComparisonResult(config.penaltyPoints);\n    }\n};\n\n/**\n * Splits both values using delimiter, trims every value and compares collections of values.\n * Returns zero-result for same multi-value attributes.\n *\n * If collections are not same checks if number of differences is less or equal maxDifferences or\n * percentage of difference is less or equal maxPercentageDifference.\n *\n * If yes then returns zero-result with additional info, else returns penaltyPoints-result.\n *\n * @param currentValue: (String) The current value.\n * @param storedValue: (String) The stored value.\n * @param config: {\n *            \"maxPercentageDifference\": (Number) The max difference percentage in the values,\n *                                                before the penalty is assigned.\n *            \"maxDifferences\": (Number) The max number of differences in the values,\n *                                       before the penalty points are assigned.\n *            \"penaltyPoints\": (Number) The number of penalty points.\n  *        }\n * @return ComparisonResult\n */\nMultiValueComparator.compare = function (currentValue, storedValue, config) {\n    if (logger.messageEnabled()) {\n        logger.message(\"MultiValueComparator.compare:currentValue: \" + JSON.stringify(currentValue));\n        logger.message(\"MultiValueComparator.compare:storedValue: \" + JSON.stringify(storedValue));\n        logger.message(\"MultiValueComparator.compare:config: \" + JSON.stringify(config));\n    }\n\n    var delimiter = \";\",\n        currentValues = splitAndTrim(currentValue, delimiter),\n        storedValues = splitAndTrim(storedValue, delimiter),\n        maxNumberOfElements = Math.max(currentValues.length, storedValues.length),\n        numberOfTheSameElements = calculateIntersection(currentValues, storedValues).length,\n        numberOfDifferences = maxNumberOfElements - numberOfTheSameElements,\n        percentageOfDifferences = calculatePercentage(numberOfDifferences, maxNumberOfElements);\n\n    if (nullOrUndefined(storedValue) && !nullOrUndefined(currentValue)) {\n        return new ComparisonResult(true);\n    }\n\n    if (logger.messageEnabled()) {\n        logger.message(numberOfTheSameElements + \" of \" + maxNumberOfElements + \" are same\");\n    }\n\n    if (maxNumberOfElements === 0) {\n        logger.message(\"Ignored because no attributes found in both profiles\");\n        return ComparisonResult.ZERO_PENALTY_POINTS;\n    }\n\n    if (numberOfTheSameElements === maxNumberOfElements) {\n        logger.message(\"Ignored because all attributes are same\");\n        return ComparisonResult.ZERO_PENALTY_POINTS;\n    }\n\n    if (numberOfDifferences > config.maxDifferences) {\n        if (logger.messageEnabled()) {\n            logger.message(\"Would be ignored if not more than \" + config.maxDifferences + \" differences\");\n        }\n        return new ComparisonResult(config.penaltyPoints);\n    }\n\n    if (percentageOfDifferences > config.maxPercentageDifference) {\n        if (logger.messageEnabled()) {\n            logger.message(percentageOfDifferences + \" percents are different\");\n            logger.message(\"Would be ignored if not more than \" + config.maxPercentageDifference + \" percent\");\n        }\n        return new ComparisonResult(config.penaltyPoints);\n    }\n\n    if (logger.messageEnabled()) {\n        logger.message(\"Ignored because number of differences(\" + numberOfDifferences + \") not more than \"\n            + config.maxDifferences);\n        logger.message(percentageOfDifferences + \" percents are different\");\n        logger.message(\"Ignored because not more than \" + config.maxPercentageDifference + \" percent\");\n    }\n    return new ComparisonResult(true);\n};\n\n/**\n * Compares two User Agent Strings and if they are equal then returns a ComparisonResult with zero penalty\n * points assigned, otherwise returns a ComparisonResult with the given number of penalty points assigned.\n *\n * @param currentValue (String) The current value.\n * @param storedValue (String) The stored value.\n * @param config: {\n *            \"ignoreVersion\": (boolean) If the version numbers in the User Agent Strings should be ignore\n *                                       in the comparison.\n *            \"penaltyPoints\": (Number) The number of penalty points.\n *        }\n * @return A ComparisonResult.\n */\nUserAgentComparator.compare = function (currentValue, storedValue, config) {\n    if (logger.messageEnabled()) {\n        logger.message(\"UserAgentComparator.compare:currentValue: \" + JSON.stringify(currentValue));\n        logger.message(\"UserAgentComparator.compare:storedValue: \" + JSON.stringify(storedValue));\n        logger.message(\"UserAgentComparator.compare:config: \" + JSON.stringify(config));\n    }\n\n    if (config.ignoreVersion) {\n        // remove version number\n        currentValue = nullOrUndefined(currentValue) ? null : currentValue.replace(/[\\d\\.]+/g, \"\").trim();\n        storedValue = nullOrUndefined(storedValue) ? null : storedValue.replace(/[\\d\\.]+/g, \"\").trim();\n    }\n\n    return ScalarComparator.compare(currentValue, storedValue, config);\n};\n\n/**\n * Compares two locations, taking into account a degree of difference.\n *\n * @param currentValue: {\n *            \"latitude\": (Number) The current latitude.\n *            \"longitude\": (Number) The current longitude.\n *        }\n * @param storedValue: {\n *            \"latitude\": (Number) The stored latitude.\n *            \"longitude\": (Number) The stored longitude.\n *        }\n * @param config: {\n *            \"allowedRange\": (Number) The max difference allowed in the two locations, before the penalty is assigned.\n *            \"penaltyPoints\": (Number) The number of penalty points.\n*         }\n * @return ComparisonResult\n */\nGeolocationComparator.compare = function (currentValue, storedValue, config) {\n    if (logger.messageEnabled()) {\n        logger.message(\"GeolocationComparator.compare:currentValue: \" + JSON.stringify(currentValue));\n        logger.message(\"GeolocationComparator.compare:storedValue: \" + JSON.stringify(storedValue));\n        logger.message(\"GeolocationComparator.compare:config: \" + JSON.stringify(config));\n    }\n\n    // Check for undefined stored or current locations\n\n    if (undefinedLocation(currentValue) && undefinedLocation(storedValue)) {\n        return ComparisonResult.ZERO_PENALTY_POINTS;\n    }\n    if (undefinedLocation(currentValue) && !undefinedLocation(storedValue)) {\n        return new ComparisonResult(config.penaltyPoints);\n    }\n    if (!undefinedLocation(currentValue) && undefinedLocation(storedValue)) {\n        return new ComparisonResult(true);\n    }\n\n    // Both locations defined, therefore perform comparison\n\n    var distance = calculateDistance(currentValue, storedValue);\n\n    if (logger.messageEnabled()) {\n        logger.message(\"Distance between (\" + currentValue.latitude + \",\" + currentValue.longitude + \") and (\" +\n            storedValue.latitude + \",\" + storedValue.longitude + \") is \" + distance + \" miles\");\n    }\n\n    if (parseFloat(distance.toPrecision(5)) === 0) {\n        logger.message(\"Location is the same\");\n        return ComparisonResult.ZERO_PENALTY_POINTS;\n    }\n\n    if (distance <= config.allowedRange) {\n        if (logger.messageEnabled()) {\n            logger.message(\"Tolerated because distance not more then \" + config.allowedRange);\n        }\n        return new ComparisonResult(true);\n    } else {\n        if (logger.messageEnabled()) {\n            logger.message(\"Would be ignored if distance not more then \" + config.allowedRange);\n        }\n        return new ComparisonResult(config.penaltyPoints);\n    }\n};\n\n\n//---------------------------------------------------------------------------//\n//                    Device Print Logic - DO NOT MODIFY                     //\n//---------------------------------------------------------------------------//\n\n// Utility functions\n\n/**\n * Returns true if evaluating function f on each element of the Array a returns true.\n *\n * @param a: (Array) The array of elements to evaluate\n * @param f: (Function) A single argument function for mapping elements of the array to boolean.\n * @return boolean.\n */\nall = function(a, f) {\n    var i;\n    for (i = 0; i < a.length; i++) {\n        if (f(a[i]) === false) {\n            return false;\n        }\n    }\n    return true;\n};\n\n/**\n * Returns true if evaluating function f on any element of the Array a returns true.\n *\n * @param a: (Array) The array of elements to evaluate\n * @param f: (Function) A single argument function for mapping elements of the array to boolean.\n * @return boolean.\n */\nany = function(a, f) {\n    var i;\n    for (i = 0; i < a.length; i++) {\n        if (f(a[i]) === true) {\n            return true;\n        }\n    }\n    return false;\n};\n\n/**\n * Returns true if the provided location is null or has undefined longitude or latitude values.\n *\n * @param location: {\n *            \"latitude\": (Number) The latitude.\n *            \"longitude\": (Number) The longitude.\n *        }\n * @return boolean\n */\nundefinedLocation = function(location) {\n    return nullOrUndefined(location) || nullOrUndefined(location.latitude) || nullOrUndefined(location.longitude);\n};\n\n/**\n * Returns true if the provided value is null or undefined.\n *\n * @param value: a value of any type\n * @return boolean\n */\nnullOrUndefined = function(value) {\n    return value === null || value === undefined;\n};\n\n/**\n * Calculates the distances between the two locations.\n *\n * @param first: {\n *            \"latitude\": (Number) The first latitude.\n *            \"longitude\": (Number) The first longitude.\n *        }\n * @param second: {\n *            \"latitude\": (Number) The second latitude.\n *            \"longitude\": (Number) The second longitude.\n *        }\n * @return Number The distance between the two locations.\n */\ncalculateDistance = function(first, second) {\n    var factor = (Math.PI / 180),\n        theta,\n        dist;\n    function degreesToRadians(degrees) {\n        return degrees * factor;\n    }\n    function radiansToDegrees(radians) {\n        return radians / factor;\n    }\n    theta = first.longitude - second.longitude;\n    dist = Math.sin(degreesToRadians(first.latitude)) * Math.sin(degreesToRadians(second.latitude))\n        + Math.cos(degreesToRadians(first.latitude)) * Math.cos(degreesToRadians(second.latitude))\n        * Math.cos(degreesToRadians(theta));\n    dist = Math.acos(dist);\n    dist = radiansToDegrees(dist);\n    dist = dist * 60 * 1.1515;\n    return dist;\n};\n\n/**\n * Converts a String holding a delimited sequence of values into an array.\n *\n * @param text (String) The String representation of a delimited sequence of values.\n * @param delimiter (String) The character delimiting values within the text String.\n * @return (Array) The comma separated values.\n */\nsplitAndTrim = function(text, delimiter) {\n\n    var results = [],\n        i,\n        values,\n        value;\n    if (text === null) {\n        return results;\n    }\n\n    values = text.split(delimiter);\n    for (i = 0; i < values.length; i++) {\n        value = values[i].trim();\n        if (value !== \"\") {\n            results.push(value);\n        }\n    }\n\n    return results;\n};\n\n/**\n * Converts value to a percentage of range.\n *\n * @param value (Number) The actual number to be converted to a percentage.\n * @param range (Number) The total number of values (i.e. represents 100%).\n * @return (Number) The percentage.\n */\ncalculatePercentage = function(value, range) {\n    if (range === 0) {\n        return 0;\n    }\n    return parseFloat((value / range).toPrecision(2)) * 100;\n};\n\n/**\n * Creates a new array containing only those elements found in both arrays received as arguments.\n *\n * @param first (Array) The first array.\n * @param second (Array) The second array.\n * @return (Array) The elements that found in first and second.\n */\ncalculateIntersection = function(first, second) {\n    return first.filter(function(element) {\n        return second.indexOf(element) !== -1;\n    });\n};\n\nfunction getValue(obj, attributePath) {\n    var value = obj,\n        i;\n    for (i = 0; i < attributePath.length; i++) {\n        if (value === undefined) {\n            return null;\n        }\n        value = value[attributePath[i]];\n    }\n    return value;\n}\n\n\nfunction isLeafNode(attributeConfig) {\n    return attributeConfig.comparator !== undefined;\n}\n\nfunction getAttributePaths(attributeConfig, attributePath) {\n\n    var attributePaths = [],\n        attributeName,\n        attrPaths,\n        attrPath,\n        i;\n\n    for (attributeName in attributeConfig) {\n        if (attributeConfig.hasOwnProperty(attributeName)) {\n\n            if (isLeafNode(attributeConfig[attributeName])) {\n                attrPath = attributePath.slice();\n                attrPath.push(attributeName);\n                attributePaths.push(attrPath);\n            } else {\n                attrPath = attributePath.slice();\n                attrPath.push(attributeName);\n                attrPaths = getAttributePaths(attributeConfig[attributeName], attrPath);\n                for (i = 0; i < attrPaths.length; i++) {\n                    attributePaths.push(attrPaths[i]);\n                }\n            }\n        }\n    }\n\n    return attributePaths;\n}\n\nfunction getDevicePrintAttributePaths(attributeConfig) {\n    return getAttributePaths(attributeConfig, []);\n}\n\nfunction hasRequiredAttributes(devicePrint, attributeConfig) {\n\n    var attributePaths = getDevicePrintAttributePaths(attributeConfig),\n        i,\n        attrValue,\n        attrConfig;\n\n    for (i = 0; i < attributePaths.length; i++) {\n\n        attrValue = getValue(devicePrint, attributePaths[i]);\n        attrConfig = getValue(attributeConfig, attributePaths[i]);\n\n        if (attrConfig.required && attrValue === undefined) {\n            logger.warning(\"Device Print profile missing required attribute, \" + attributePaths[i]);\n            return false;\n        }\n    }\n\n    logger.message(\"device print has required attributes\");\n    return true;\n}\n\nfunction compareDevicePrintProfiles(attributeConfig, devicePrint, devicePrintProfiles, maxPenaltyPoints) {\n\n    var attributePaths = getDevicePrintAttributePaths(attributeConfig),\n        dao = sharedState.get('_DeviceIdDao'),\n        results,\n        j,\n        aggregatedComparisonResult,\n        i,\n        currentValue,\n        storedValue,\n        attrConfig,\n        comparisonResult,\n        selectedComparisonResult,\n        selectedProfile,\n        curDevicePrintProfile,\n        vals;\n\n    results = [];\n    for (j = 0; j < devicePrintProfiles.length; j++) {\n        curDevicePrintProfile = JSON.parse(org.forgerock.json.JsonValue.json(devicePrintProfiles[j]));\n        aggregatedComparisonResult = new ComparisonResult();\n        for (i = 0; i < attributePaths.length; i++) {\n\n            currentValue = getValue(devicePrint, attributePaths[i]);\n            storedValue = getValue(curDevicePrintProfile.devicePrint, attributePaths[i]);\n            attrConfig = getValue(attributeConfig, attributePaths[i]);\n\n            if (storedValue === null) {\n                comparisonResult = new ComparisonResult(attrConfig.penaltyPoints);\n            } else {\n                comparisonResult = attrConfig.comparator.compare(currentValue, storedValue, attrConfig.args);\n            }\n\n            if (logger.messageEnabled()) {\n                logger.message(\"Comparing attribute path: \" + attributePaths[i]\n                    + \", Comparison result: successful=\" + comparisonResult.isSuccessful() + \", penaltyPoints=\"\n                    + comparisonResult.penaltyPoints + \", additionalInfoInCurrentValue=\"\n                    + comparisonResult.additionalInfoInCurrentValue);\n            }\n            aggregatedComparisonResult.addComparisonResult(comparisonResult);\n        }\n        if (logger.messageEnabled()) {\n            logger.message(\"Aggregated comparison result: successful=\"\n                + aggregatedComparisonResult.isSuccessful() + \", penaltyPoints=\"\n                + aggregatedComparisonResult.penaltyPoints + \", additionalInfoInCurrentValue=\"\n                + aggregatedComparisonResult.additionalInfoInCurrentValue);\n        }\n\n        results.push({\n            key: aggregatedComparisonResult,\n            value: devicePrintProfiles[j]\n        });\n    }\n\n    if (results.length === 0) {\n        return null;\n    }\n\n    results.sort(function(a, b) {\n        return ComparisonResult.compare(a.key, b.key);\n    });\n    selectedComparisonResult = results[0].key;\n    if (logger.messageEnabled()) {\n        logger.message(\"Selected comparison result: successful=\" + selectedComparisonResult.isSuccessful()\n            + \", penaltyPoints=\" + selectedComparisonResult.penaltyPoints + \", additionalInfoInCurrentValue=\"\n            + selectedComparisonResult.additionalInfoInCurrentValue);\n    }\n\n    selectedProfile = null;\n    if (selectedComparisonResult.penaltyPoints <= maxPenaltyPoints) {\n        selectedProfile = results[0].value;\n        if (logger.messageEnabled()) {\n            logger.message(\"Selected profile: \" + selectedProfile +\n                \" with \" + selectedComparisonResult.penaltyPoints + \" penalty points\");\n        }\n    }\n\n    if (selectedProfile === null) {\n        return false;\n    }\n\n    /* update profile */\n    selectedProfile.put(\"selectionCounter\",\n        java.lang.Integer.valueOf(parseInt(selectedProfile.get(\"selectionCounter\"), 10) + 1));\n    selectedProfile.put(\"lastSelectedDate\", java.lang.Long.valueOf(new Date().getTime()));\n    selectedProfile.put(\"devicePrint\", devicePrint);\n\n    vals = [];\n    for (i = 0; i < devicePrintProfiles.length; i++) {\n        vals.push(org.forgerock.json.JsonValue.json(devicePrintProfiles[i]));\n    }\n\n    dao.saveDeviceProfiles(username, realm, vals);\n\n    return true;\n}\n\nfunction matchDevicePrint() {\n\n    if (!username) {\n        logger.error(\"Username not set. Cannot compare user's device print profiles.\");\n        authState = FAILED;\n    } else {\n\n        if (logger.messageEnabled()) {\n            logger.message(\"client devicePrint: \" + clientScriptOutputData);\n        }\n\n        var getProfiles = function () {\n\n                function isExpiredProfile(devicePrintProfile) {\n                    var expirationDate = new Date(),\n                        lastSelectedDate;\n                    expirationDate.setDate(expirationDate.getDate() - config.profileExpiration);\n\n                    lastSelectedDate = new Date(devicePrintProfile.lastSelectedDate);\n\n                    return lastSelectedDate < expirationDate;\n                }\n\n                function getNotExpiredProfiles() {\n                    var profile,\n                        dao = sharedState.get('_DeviceIdDao'),\n                        results = [],\n                        profiles,\n                        iter;\n\n                    profiles = dao.getDeviceProfiles(username, realm);\n\n                    if (profiles) {\n                        iter = profiles.iterator();\n\n                        while (iter.hasNext()) {\n                            profile = iter.next().getObject();\n                            if (!isExpiredProfile(profile)) {\n                                results.push(profile);\n                            }\n                        }\n                    }\n                    if (logger.messageEnabled()) {\n                        logger.message(\"stored non-expired profiles: \" + results);\n                    }\n                    return results;\n                }\n\n                return getNotExpiredProfiles();\n            },\n            devicePrint = JSON.parse(clientScriptOutputData),\n            devicePrintProfiles = getProfiles();\n\n        if (!hasRequiredAttributes(devicePrint, config.attributes)) {\n            logger.message(\"devicePrint.hasRequiredAttributes: false\");\n            // Will fail this module but fall-through to next module. Which should be OTP.\n            authState = FAILED;\n        } else if (compareDevicePrintProfiles(config.attributes, devicePrint, devicePrintProfiles, config.maxPenaltyPoints)) {\n            logger.message(\"devicePrint.hasValidProfile: true\");\n            authState = SUCCESS;\n        } else {\n            logger.message(\"devicePrint.hasValidProfile: false\");\n            sharedState.put('devicePrintProfile', JSON.stringify(devicePrint));\n            // Will fail this module but fall-through to next module. Which should be OTP.\n            authState = FAILED;\n        }\n    }\n}\n\nmatchDevicePrint();",
    "description" : "Default global script for server side Device Id (Match) Authentication Module",
    "lastModifiedBy" : "id=dsameuser,ou=user,dc=openam,dc=forgerock,dc=org",
    "context" : "AUTHENTICATION_SERVER_SIDE",
    "lastModifiedDate" : "1433147666269",
    "name" : "Device Id (Match) - Server Side"
  }
}