{
  "metadata" : {
    "realm" : null,
    "entityType" : "ScriptingService",
    "entityId" : "default/globalScripts/36863ffb-40ec-48b9-94b1-9a99f71cc3b5",
    "uid" : "ou=36863ffb-40ec-48b9-94b1-9a99f71cc3b5,ou=globalScripts,ou=default,ou=GlobalConfig,ou=1.0,ou=ScriptingService,ou=services,ou=am-config",
    "sunServiceID" : "globalScript",
    "objectClass" : [ "sunServiceComponent", "top" ],
    "pathParams" : { },
    "ou" : [ "36863ffb-40ec-48b9-94b1-9a99f71cc3b5" ]
  },
  "data" : {
    "_id" : "default/globalScripts/36863ffb-40ec-48b9-94b1-9a99f71cc3b5",
    "_type" : {
      "_id" : "ScriptingService",
      "name" : "ScriptingService",
      "collection" : false
    },
    "createdBy" : "id=dsameuser,ou=user,dc=openam,dc=forgerock,dc=org",
    "evaluatorVersion" : "V1_0",
    "creationDate" : "1433147666269",
    "language" : "GROOVY",
    "script" : "/*\n * Copyright 2014-2020 ForgeRock AS. All Rights Reserved\n *\n * Use of this code requires a commercial software license with ForgeRock AS.\n * or with one of its affiliates. All use shall be exclusively subject\n * to such license between the licensee and ForgeRock AS.\n */\nimport com.iplanet.sso.SSOException\nimport com.sun.identity.idm.IdRepoException\nimport org.forgerock.oauth2.core.exceptions.InvalidRequestException\nimport org.forgerock.oauth2.core.UserInfoClaims\nimport org.forgerock.openidconnect.Claim\n\n/*\n* Defined variables:\n* logger - always presents, the \"OAuth2Provider\" debug logger instance\n* claims - always present, default server provided claims - Map<String, Object>\n* claimObjects - always present, default server provided claims - List<Claim>\n* session - present if the request contains the session cookie, the user's session object\n* identity - always present, the identity of the resource owner\n* scopes - always present, the requested scopes\n* scriptName - always present, the display name of the script\n* requestProperties - always present, contains a map of request properties:\n*                     requestUri - the request URI\n*                     realm - the realm that the request relates to\n*                     requestParams - a map of the request params and/or posted data. Each value is a list of one or\n*                     more properties. Please note that these should be handled in accordance with OWASP best practices.\n* clientProperties - present if the client specified in the request was identified, contains a map of client\n*                    properties:\n*                    clientId - the client's Uri for the request locale\n*                    allowedGrantTypes - list of the allowed grant types (org.forgerock.oauth2.core.GrantType)\n*                                        for the client\n*                    allowedResponseTypes - list of the allowed response types for the client\n*                    allowedScopes - list of the allowed scopes for the client\n*                    customProperties - A map of the custom properties of the client.\n*                                       Lists or maps will be included as sub-maps, e.g:\n*                                       testMap[Key1]=Value1 will be returned as testmap -> Key1 -> Value1\n* requestedClaims - Map<String, Set<String>>\n*                  always present, not empty if the request contains a claims parameter and server has enabled\n*                  claims_parameter_supported, map of requested claims to possible values, otherwise empty,\n*                  requested claims with no requested values will have a key but no value in the map. A key with\n*                  a single value in its Set indicates this is the only value that should be returned.\n* requestedTypedClaims - List<Claim>\n*                       always present, not empty if the request contains a claims parameter and server has enabled\n*                       claims_parameter_supported, list of requested claims with claim name, requested possible values\n*                       and if claim is essential, otherwise empty,\n*                       requested claims with no requested values will have a claim with no values. A claims with\n*                       a single value indicates this is the only value that should be returned.\n* claimsLocales - the values from the 'claims_locales' parameter - List<String>\n* Required to return a Map of claims to be added to the id_token claims\n*\n* Expected return value structure:\n* UserInfoClaims {\n*    Map<String, Object> values; // The values of the claims for the user information\n*    Map<String, List<String>> compositeScopes; // Mapping of scope name to a list of claim names.\n* }\n*/\n\n// user session not guaranteed to be present\nboolean sessionPresent = session != null\n\n/*\n * Pulls first value from users profile attribute\n *\n * @param claim The claim object.\n * @param attr The profile attribute name.\n */\ndef fromSet = { claim, attr ->\n    if (attr != null && attr.size() == 1){\n        attr.iterator().next()\n    } else if (attr != null && attr.size() > 1){\n        attr\n    } else if (logger.warningEnabled()) {\n        logger.warning(\"OpenAMScopeValidator.getUserInfo(): Got an empty result for claim=$claim\");\n    }\n}\n\n// ---vvvvvvvvvv--- EXAMPLE CLAIM ATTRIBUTE RESOLVER FUNCTIONS ---vvvvvvvvvv---\n/*\n * Claim resolver which resolves the value of the claim from its requested values.\n *\n * This resolver will return a value if the claim has one requested values, otherwise an exception is thrown.\n */\ndefaultClaimResolver = { claim ->\n    if (claim.getValues().size() == 1) {\n        [(claim.getName()): claim.getValues().iterator().next()]\n    } else {\n        [:]\n    }\n}\n\n/*\n * Claim resolver which resolves the value of the claim by looking up the user's profile.\n *\n * This resolver will return a value for the claim if:\n * # the user's profile attribute is not null\n * # AND the claim contains no requested values\n * # OR the claim contains requested values and the value from the user's profile is in the list of values\n *\n * If no match is found an exception is thrown.\n */\nuserProfileClaimResolver = { attribute, claim, identity ->\n    if (identity != null) {\n        userProfileValue = fromSet(claim.getName(), identity.getAttribute(attribute))\n        if (userProfileValue != null && (claim.getValues() == null || claim.getValues().isEmpty() || claim.getValues().contains(userProfileValue))) {\n            return [(claim.getName()): userProfileValue]\n        }\n    }\n    [:]\n}\n\n/*\n * Claim resolver which resolves the value of the claim of the user's address.\n *\n * This resolver will return a value for the claim if:\n * # the value of the address is not null\n *\n */\nuserAddressClaimResolver = { claim, identity ->\n    if (identity != null) {\n        addressFormattedValue = fromSet(claim.getName(), identity.getAttribute(\"postaladdress\"))\n        if (addressFormattedValue != null) {\n            return [\n                    \"formatted\" : addressFormattedValue\n            ]\n        }\n    }\n    [:]\n}\n\n/*\n * Claim resolver which resolves the value of the claim by looking up the user's profile.\n *\n * This resolver will return a value for the claim if:\n * # the user's profile attribute is not null\n * # AND the claim contains no requested values\n * # OR the claim contains requested values and the value from the user's profile is in the list of values\n *\n * If the claim is essential and no value is found an InvalidRequestException will be thrown and returned to the user.\n * If no match is found an exception is thrown.\n */\nessentialClaimResolver = { attribute, claim, identity ->\n    if (identity != null) {\n        userProfileValue = fromSet(claim.getName(), identity.getAttribute(attribute))\n        if (claim.isEssential() && (userProfileValue == null || userProfileValue.isEmpty())) {\n            throw new InvalidRequestException(\"Could not provide value for essential claim $claim\")\n        }\n        if (userProfileValue != null && (claim.getValues() == null || claim.getValues().isEmpty() || claim.getValues().contains(userProfileValue))) {\n            return [(claim.getName()): userProfileValue]\n        }\n    }\n    return [:]\n}\n\n/*\n * Claim resolver which expects the user's profile attribute value to be in the following format:\n * \"language_tag|value_for_language,...\".\n *\n * This resolver will take the list of requested languages from the 'claims_locales' authorize request\n * parameter and attempt to match it to a value from the users' profile attribute.\n * If no match is found an exception is thrown.\n */\nclaimLocalesClaimResolver = { attribute, claim, identity ->\n    if (identity != null) {\n        userProfileValue = fromSet(claim.getName(), identity.getAttribute(attribute))\n        if (userProfileValue != null) {\n            localeValues = parseLocaleAwareString(userProfileValue)\n            locale = claimsLocales.find { locale -> localeValues.containsKey(locale) }\n            if (locale != null) {\n                return [(claim.getName()): localeValues.get(locale)]\n            }\n        }\n    }\n    return [:]\n}\n\n/*\n * Claim resolver which expects the user's profile attribute value to be in the following format:\n * \"language_tag|value_for_language,...\".\n *\n * This resolver will take the language tag specified in the claim object and attempt to match it to a value\n * from the users' profile attribute. If no match is found an exception is thrown.\n */\nlanguageTagClaimResolver = { attribute, claim, identity ->\n    if (identity != null) {\n        userProfileValue = fromSet(claim.getName(), identity.getAttribute(attribute))\n        if (userProfileValue != null) {\n            localeValues = parseLocaleAwareString(userProfileValue)\n            if (claim.getLocale() != null) {\n                if (localeValues.containsKey(claim.getLocale())) {\n                    return [(claim.getName()): localeValues.get(claim.getLocale())]\n                } else {\n                    entry = localeValues.entrySet().iterator().next()\n                    return [(claim.getName() + \"#\" + entry.getKey()): entry.getValue()]\n                }\n            } else {\n                entry = localeValues.entrySet().iterator().next()\n                return [(claim.getName()): entry.getValue()]\n            }\n        }\n    }\n    return [:]\n}\n\n/*\n * Given a string \"en|English,jp|Japenese,fr_CA|French Canadian\" will return map of locale -> value.\n */\nparseLocaleAwareString = { s ->\n    return result = s.split(\",\").collectEntries { entry ->\n        split = entry.split(\"\\\\|\")\n        [(split[0]): value = split[1]]\n    }\n}\n// ---^^^^^^^^^^--- EXAMPLE CLAIM ATTRIBUTE RESOLVER FUNCTIONS ---^^^^^^^^^^---\n\n// -------------- UPDATE THIS TO CHANGE CLAIM TO ATTRIBUTE MAPPING FUNCTIONS ---------------\n/*\n * List of claim resolver mappings.\n */\n// [ {claim}: {attribute retriever}, ... ]\nclaimAttributes = [\n        \"email\": userProfileClaimResolver.curry(\"mail\"),\n        \"address\": { claim, identity -> [ \"address\" : userAddressClaimResolver(claim, identity) ] },\n        \"phone_number\": userProfileClaimResolver.curry(\"telephonenumber\"),\n        \"given_name\": userProfileClaimResolver.curry(\"givenname\"),\n        \"zoneinfo\": userProfileClaimResolver.curry(\"preferredtimezone\"),\n        \"family_name\": userProfileClaimResolver.curry(\"sn\"),\n        \"locale\": userProfileClaimResolver.curry(\"preferredlocale\"),\n        \"name\": userProfileClaimResolver.curry(\"cn\")\n]\n\n\n// -------------- UPDATE THIS TO CHANGE SCOPE TO CLAIM MAPPINGS --------------\n/*\n * Map of scopes to claim objects.\n */\n// {scope}: [ {claim}, ... ]\nscopeClaimsMap = [\n        \"email\": [ \"email\" ],\n        \"address\": [ \"address\" ],\n        \"phone\": [ \"phone_number\" ],\n        \"profile\": [ \"given_name\", \"zoneinfo\", \"family_name\", \"locale\", \"name\" ]\n]\n\n\n// ---------------- UPDATE BELOW FOR ADVANCED USAGES -------------------\nif (logger.messageEnabled()) {\n    scopes.findAll { s -> !(\"openid\".equals(s) || scopeClaimsMap.containsKey(s)) }.each { s ->\n        logger.message(\"OpenAMScopeValidator.getUserInfo()::Message: scope not bound to claims: $s\")\n    }\n}\n\n/*\n * Computes the claims return key and value. The key may be a different value if the claim value is not in\n * the requested language.\n */\ndef computeClaim = { claim ->\n    try {\n        claimResolver = claimAttributes.get(claim.getName(), { claimObj, identity -> defaultClaimResolver(claim)})\n        claimResolver(claim, identity)\n    } catch (IdRepoException e) {\n        if (logger.warningEnabled()) {\n            logger.warning(\"OpenAMScopeValidator.getUserInfo(): Unable to retrieve attribute=$attribute\", e);\n        }\n    } catch (SSOException e) {\n        if (logger.warningEnabled()) {\n            logger.warning(\"OpenAMScopeValidator.getUserInfo(): Unable to retrieve attribute=$attribute\", e);\n        }\n    }\n}\n\n/*\n * Converts requested scopes into claim objects based on the scope mappings in scopeClaimsMap.\n */\ndef convertScopeToClaims = {\n    scopes.findAll { scope -> \"openid\" != scope && scopeClaimsMap.containsKey(scope) }.collectMany { scope ->\n        scopeClaimsMap.get(scope).collect { claim ->\n            new Claim(claim)\n        }\n    }\n}\n\n// Creates a full list of claims to resolve from requested scopes, claims provided by AS and requested claims\ndef claimsToResolve = convertScopeToClaims() + claimObjects + requestedTypedClaims\n\n// Computes the claim return key and values for all requested claims\ncomputedClaims = claimsToResolve.collectEntries() { claim ->\n    result = computeClaim(claim)\n}\n\n// Computes composite scopes\ndef compositeScopes = scopeClaimsMap.findAll { scope ->\n    scopes.contains(scope.key)\n}\n\nreturn new UserInfoClaims((Map)computedClaims, (Map)compositeScopes)",
    "description" : "Default global script for OIDC claims",
    "lastModifiedBy" : "id=dsameuser,ou=user,dc=openam,dc=forgerock,dc=org",
    "context" : "OIDC_CLAIMS",
    "lastModifiedDate" : "1433147666269",
    "name" : "OIDC Claims Script"
  }
}